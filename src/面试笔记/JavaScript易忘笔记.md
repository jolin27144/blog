1.  数据类型包括

    ```
     Number,BigInt,String,Boolean,Symbol,Undefined,Null
     Object
    ```

2.  如何获取安全的 undefined 值？

    ```
     因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。

     表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。

     按惯例我们用 void 0 来获得 undefined。
    ```

3.  js 中整数的安全范围是多少？

    ```
     安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，
     即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中
     被定义为 Number.MIN_SAFE_INTEGER。

     如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次
     计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数
     来判断。

    ```

4.  isNaN 和 Number.isNaN 函数的区别？

    ```
     函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会
     返回 true ，会影响 NaN 的判断。

     函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为
     准确。
    ```

5.  类型转换抽象操作

    ```
    Ⅰ. ToNumber

    Ⅱ. ToString

    Ⅲ. ToBoolean

    ```

6.  {} 和 [] 的 valueOf 和 toString 的结果是什么？

    ```
    {} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"

    [] 的 valueOf 结果为 [] ，toString 的结果为 ""

    ```

7.  什么是假值对象？

    ```
    浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和
    普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 最常见的例子是 document.all，它
    是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。
    ```

8.  "+"运算

9.  ">"运算符

10. "=="运算符

    ```
        （1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。

        （2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。

        （3）null 和 undefined 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。

        （4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。

        （5）如果一个操作值为 NaN ，则相等比较返回 false（ NaN 本身也不等于 NaN ）。

        （6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。
    ```

11. "==="运算符

12. 什么情况下会发生布尔值的隐式强制类型转换？

    ```
        （1） if (..) 语句中的条件判断表达式。
        （2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。
        （3） while (..) 和 do..while(..) 循环中的条件判断表达式。
        （4） ? : 中的条件判断表达式。
        （5） 逻辑运算符 ||（逻辑或）和 &&（逻辑与）左边的操作数（作为条件判断表达式）。
    ```

13. || 和 && 操作符的返回值？

    ```
       || 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。

       对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。

       && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

       || 和 && 返回它们其中一个操作数的值，而非条件判断的结果
    ```

14. Symbol 值的强制类型转换？

    ```
        ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。

        Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果
        都是 true ）。
    ```

15. 如何将字符串转化为数字，例如 '12.3b'?

    ```
    （1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。

    （2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。

    （3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。

    （4）使用 + 操作符的隐式转换。
    ```

16. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?

    ```
        // 方法一
        function format(number) {
        return number && number.replace(/(?!^)(?=(\d{3})+\.)/g, ",");
        }
        // 方法二
        function format1(number) {
        return Intl.NumberFormat().format(number)
        }
        // 方法三
        function format2(number) {
        return number.toLocaleString('en')
        }
    ```

17. this 绑定

    ```
        1. 绑定类型
          (1) 默认绑定

          (2) 隐含绑定

          (3) 明确绑定
              a. call,apply
              b. bind

          (4) new绑定

        2. 绑定优先级

          (1) new绑定
          (2) 明确绑定
          (3) 隐含绑定
          (4) 默认绑定

    ```

18. eval 是做什么的？

    ```
        它的功能是把对应的字符串解析成 JS 代码并运行。

        应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。
    ```

19. 什么是 DOM 和 BOM？

    ```
        DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。

        BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM
        的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）
        对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 locati
        on 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对
        象的子对象。
    ```

20. 三种事件模型是什么？

    ```
        事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。

        第一种事件模型是最早的 DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实
        现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。

        第二种事件模型是 IE 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。

        第三种是 DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。
    ```

21. 事件委托是什么？

    ```
        事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到
        目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。

        使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。
    ```

22. 什么是闭包，为什么要用它？

    ```
        闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以
        访问到当前函数的局部变量。

        闭包有两个常用的用途。

        (1) 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外
        部访问到函数内部的变量，可以使用这种方法来创建私有变量。

        (2) 函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以
        这个变量对象不会被回收。

        其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。
    ```

23. new 操作符具体干了什么呢？如何实现？

    ```
        // （1）首先创建了一个新的空对象
        // （2）设置原型，将对象的原型设置为函数的 prototype 对象。
        // （3）让函数的 this 指向这个对象，执行构造函数的代码
        // （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

        // 实现:

        function myNew(constructor, ...params) {
        let newObject = null,
            result = null;

        // 参数判断
        if (typeof constructor !== 'function') {
            console.error('type error');
            return;
        }

        // 新建一个空对象，对象的原型为构造函数的 prototype 对象
        newObject = Object.create(constructor.prototype);

        // 将 this 指向新建对象，并执行函数
        result = constructor.apply(newObject, params);

        // 判断返回对象
        let flag =
            result && (typeof result === 'object' || typeof result === 'function');

        // 判断返回结果
        return flag ? result : newObject;
        }

        // 使用方法

        function Book(...ids) {
        this.Book = [1, 2, 3, 4];
        this.ids = ids;
        }

        console.log(myNew(Book, 1, 2, 3, 4));

    ```

24. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？

    ```
        hasOwnProperty

        所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和
        in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。
    ```

25. js 延迟加载的方式有哪些？

    ```
        js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。

        我了解到的几种方式是：

        第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。

        第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。

        第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。

        第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。
    ```

26. js 的几种模块规范？

    ```
        js 中现在比较成熟的有四种模块加载方案。

        第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是
        服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式
        加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。

        第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定
        义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。

        第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js
        的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。

        第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。
    ```

27. AMD 和 CMD 规范的区别？

    ```
        它们之间的主要区别有两个方面。

        （1）第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇 就近依赖，只有在用到某个模块的时候再去 require。

        （2）第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。
    ```

28. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。

    ```
        1.CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。

        2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
    ```

29. 