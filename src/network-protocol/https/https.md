## HTTPS 要解决 HTTP 中的问题

1. 明文传输，很容易被窃听
2. 没有验证数据的完整性，容易被篡改
3. 没有验证对端的身份，容易被伪装

即： 机密性、完整性、身份认证和不可否认

机密性：对称加密 + 混合加密 (加密算法)
完整性：摘要算法实现 (摘要算法)
身份认证：数字签名 (私钥加密摘要,公钥解密摘要，对比)
不可否认：数字签名 (私钥加密摘要,公钥解密摘要，对比

上面缺了怎么保证公钥是真的？ -》 CA 说了算

下面是推演过程：
↓ 对称加密（怎么交换密钥？）
↓ 非对称加密（但基于复杂的数学难题，运行速度很慢？）
↓ 混合加密（怎么保证完整性？不被修改？）
↓ 摘要算法（怎么确认身份？提示：私钥只能本人持有,是一个身份标志）
↓ 数字签名（怎么保证公钥就是你的？提示：找第三方来保证）
↓ 数字证书、CA

## HTTPS 中的 S 代表什么

"HTTP over TCP/IP”变成 “HTTP over SSL/TLS"

SSL 即安全套接层（Secure Sockets Layer）

TLS（传输层安全，Transport Layer Security）

SSL 1.0 -> SSL 2.0 -> SSL 3.0 -> SSL3.1 === TLS 1.0 -> TLS 1.1 -> TLS 1.2 -> TLS 1.3

![img.png](img.png)

## TLS 混合加密

在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。

然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。

因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。对方拿到密文后用私钥解密，取出会话密钥。

这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。

![img_1.png](img_1.png)

## HTTPS 握手过程


## 常见问题

### TLS 支持双向认证和单向认证。

如果是单向认证，也就是目前大多数的用法，只发送服务器的公钥，验证服务器的身份。

如果是双向认证，那么服务器和客户端都要发送各自的公钥，互相验证对方的身份，一个常见的场景就是网银的 U 盾。

### 私钥加密后任何人都可以用公钥解密，这有什么用呢？

因为私钥只能由一个人秘密持有，所以它加密的数据谁都可以解密，没有私密性，但这就是它的价值所在，可以证明这个数据就是私钥持有人发布的，可以用来做身份认证。

1. 私钥只能被一个人秘密持有，别人是不会有的。
2. 任何人都可以用公钥解密私钥加密的数据，那么就证明数据是被对应的私钥加密的。
3. 从 1/2 可以推出，数据必然是私钥持有者发出的，否则公钥必然会解密失败。
4. 从 3 推出，发送者就是私钥持有者，也就确认了发送者的身份。
